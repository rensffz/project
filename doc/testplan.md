# Модуль game
## Метод Game.restart()

### Тест № 1.1
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое количество жизней с фактическим и удостовериться, что количество жизней в классе Game было определено верно.
__Тип__: позитивный тест
__Входные данные__: длина списка жизней (int)
__Ожидаемый результат__: равенство предоставленной длины и константы, равной количеству жизней
__Описание процесса__:  После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №1 этого блока проверяется, что количество элементов списка жизней равно количеству жизней, количество жизней берётся из модуля констант.

### Тест № 1.2
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое количество врагов с фактическим и удостовериться, что количество врагов в классе Game было определено верно.
__Тип__: позитивный
__Входные данные__: длина списка врагов (int)
__Ожидаемый результат__: равенство предоставленной длины и константы, равной количеству врагов
__Описание процесса__:  После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №2 этого блока проверяется, что количество элементов списка врагов равно количеству жизней, количество врагов берётся из модуля констант.  

### Тест № 1.3
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение начального времени с фактическим и удостовериться, что таймер в классе Game устанавливается верно.
__Тип__: позитивный тест
__Входные данные__: атрибут, хранящий значение таймера (int)
__Ожидаемый результат__: равенство предоставленных данных и константы, равной начальному значению таймера
__Описание процесса__:  После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №3 этого блока проверяется, что начальное значение таймера, хранящееся в атрибуте класса, равно соответствующей константе, определённой в модуле с константами.  

### Тест № 1.4
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение начального счёта с фактическим и удостовериться, что счётчик в классе Game устанавливается верно.
__Тип__: позитивный тест
__Входные данные__: атрибут, хранящий значение счёта на момент начала игры (int)
__Ожидаемый результат__: равенство предоставленных данных нулю
__Описание процесса__: После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №4 этого блока проверяется, что начальное значение счётчика, хранящееся в атрибуте класса, равно нулю.  

### Тест № 1.5
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение состояния игры с фактическим и удостовериться, что установка состояния работает верно при перезапуске.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий числовую характеристику текущего состояния игры (int)
__Ожидаемый результат__: равенство предоставленных данных единице
__Описание процесса__: После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №5 этого блока проверяется, что установленное значение состояния игры, хранящееся в атрибуте класса, равно единице.  

### Тест № 1.6
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение результата с фактическим и удостовериться, что флажок результата обнуляется при перезапуске игры (становится в начальное значение).
__Тип__: позитивный
__Входные данные__: атрибут, хранящий результат игры (int)
__Ожидаемый результат__: равенство предоставленных данных нулю.
__Описание процесса__: После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №6 этого блока проверяется, что результат игры, хранящийся в атрибуте класса, равен нулю.  

### Тест № 1.7
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение координаты x главного героя с фактическим и удостовериться, что по оси OX герой встает в начальную координату при перезапуске игры.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий координату x персонажа (int)
__Ожидаемый результат__: равенство предоставленных данных и константы, равной начальному значению координаты по оси иксов.
__Описание процесса__: После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №7 этого блока проверяется, что координата x главного управляемого персонажа, хранящаяся в атрибуте класса, равна начальному значению координаты по оси иксов (взятому из модуля с константами).

### Тест № 1.8
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение координаты y главного героя с фактическим и удостовериться, что по оси OY герой встает в начальную координату при перезапуске игры.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий координату y персонажа (int)
__Ожидаемый результат__: равенство предоставленных данных и константы, равной начальному значению координаты по оси игреков.
__Описание процесса__: После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №8 этого блока проверяется, что координата y главного управляемого персонажа, хранящаяся в атрибуте класса, равна начальному значению координаты по оси игреков (взятому из модуля с константами).  

### Тест № 1.9
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение скорости изменения координаты x главного героя с фактическим и удостовериться, что по оси OX эта величина равна 0 при перезапуске игры.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий значение скорости изменения координаты x главного героя (int)
__Ожидаемый результат__: равенство предоставленных данных 0
__Описание процесса__:  После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №9 этого блока проверяется, что скорость изменения координаты x главного героя равна 0.  

### Тест № 1.10
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение скорости изменения координаты y главного героя с фактическим и удостовериться, что по оси OY эта величина равна 0 при перезапуске игры.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий значение скорости изменения координаты y главного героя (int)
__Ожидаемый результат__: равенство предоставленных данных 0
__Описание процесса__:  После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №10 этого блока проверяется, что скорость изменения координаты y главного героя равна 0.  

### Тест № 1.11
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение координаты x каждого из врагов с фактическим и удостовериться, что при перезапуске игры все положения врагов по оси OX генерируются корректно.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий координату x врага (int)
__Ожидаемый результат__: координата x врага не находится в области, занимаемой главным персонажем в начале игры.
__Описание процесса__:  После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тестах №11 и №12 этого блока запущен цикл, перебирающий всех врагов, и проверяется, что координата x вражеского персонажа, хранящаяся в атрибуте класса, не попадает в "безопасный" диапазон главного героя: стартовую позицию и её окрестность по оси OX.

### Тест № 1.12
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемое значение координаты y каждого из врагов с фактическим и удостовериться, что при перезапуске игры все положения врагов по оси OY генерируются корректно.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий координату y врага (int)
__Ожидаемый результат__: координата y врага не находится в области, занимаемой главным персонажем в начале игры.
__Описание процесса__:  После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тестах №11 и №12 этого блока запущен цикл, перебирающий всех врагов, и проверяется, что координата y вражеского персонажа, хранящаяся в атрибуте класса, не попадает в "безопасный" диапазон главного героя: стартовую позицию и её окрестность по оси OY.  

### Тест № 1.13
__Цель__: Проверить работу метода restart() класса Game, сравнив ожидаемые значение координат каждой из жизней с фактическими и удостовериться, что при перезапуске игры все координаты жизней заполнены корректно.
__Тип__: позитивный
__Входные данные__: кортеж (x, y), где x - координата x отрисовки жизни, y - координата y отрисовки жизни
__Ожидаемый результат__: равенство передаваемых входных данных и кортежа, содержащего верные позиции жизни
__Описание процесса__:  После инициализации игры вызывается метод restart(), затем следует ряд проверок. В тесте №13 запускается цикл, проходящий по длине списка жизней (атрибуту тестируемого класса), и на каждой итерации цикла проверяется равенство входных данных и кортежа координат (x, y), считающихся следующим алгоритмом:  
            x = ScreenWidth - (i + 1)∙w_i
            y = 0, 
    где ScreenWidth - ширина экрана, взятая из модуля с константами, i - соответствующая итерация цикла, w_i - ширина изображения элемента с индексом i в списке жизней.  
    
## Метод MainLoop()

### Тест № 1.1
__Цель__: Проверить поведение программы при нажатии кнопки "Закрыть"
__Тип__: позитивный
__Входные данные__: флаг исполнения game.running (bool)
__Ожидаемый результат__: game.running = False
__Описание процесса__:  Создаётся имитация нажатия кнопки "Закрыть" (pygame.event.post(pygame.event.Event(pygame.QUIT))) и запускается главный игровой цикл. Ожидается, что флаг исполнения должен смениться логическим значением "Ложь".  

### Тест № 1.2
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение состояния игры с фактическим и удостовериться, что установка состояния работает верно при запуске (нажатии пробела).
__Тип__: позитивный
__Входные данные__: атрибут, хранящий числовую характеристику текущего состояния игры (int)
__Ожидаемый результат__: равенство входных данных единице
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №2 этого блока проверяется, что установленное значение состояния игры, хранящееся в атрибуте класса, устанавливается в единицу.  

### Тест № 1.3
__Цель__: Проверить поведение программы при нажатии кнопки "Закрыть" после запуска главного игрового цикла.
__Тип__: позитивный
__Входные данные__: флаг исполнения game.running (bool)
__Ожидаемый результат__: game.running = False
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №3 этого блока проверяется, что флаг исполнения равен логическому значению "Ложь" путем вызова теста 1.1 текущего блока.

### Тест № 1.4
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение координаты x главного героя с фактическим и удостовериться, что по оси OX герой встает в начальную координату при запуске игры.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий координату x персонажа (int)
__Ожидаемый результат__: равенство предоставленных данных и константы, равной начальному значению координаты по оси иксов.
__Описание процесса__: После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №4 этого блока проверяется, что координата x главного управляемого персонажа, хранящаяся в атрибуте класса, равна начальному значению координаты по оси иксов (взятому из модуля с константами).  

### Тест № 1.5
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение координаты y главного героя с фактическим и удостовериться, что по оси OY герой встает в начальную координату при запуске игры.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий координату y персонажа (int)
__Ожидаемый результат__: равенство предоставленных данных и константы, равной начальному значению координаты по оси игреков.
__Описание процесса__: После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №5 этого блока проверяется, что координата y главного управляемого персонажа, хранящаяся в атрибуте класса, равна начальному значению координаты по оси игреков (взятому из модуля с константами).  

### Тест № 1.6
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое количество жизней с фактическим и удостовериться, что количество жизней при запуске игры было определено верно.
__Тип__: позитивный тест
__Входные данные__: длина списка жизней (int)
__Ожидаемый результат__: равенство предоставленной длины и константы, равной количеству жизней
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №6 этого блока проверяется, что количество элементов списка жизней равно количеству жизней; количество жизней берётся из модуля констант.  

### Тест № 1.7
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое количество врагов с фактическим и удостовериться, что количество врагов при запуске игры было определено верно.
__Тип__: позитивный
__Входные данные__: длина списка врагов (int)
__Ожидаемый результат__: равенство предоставленной длины и константы, равной количеству врагов
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №7 этого блока проверяется, что количество элементов списка врагов равно количеству жизней, количество врагов берётся из модуля констант.  

### Тест № 1.8
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение начального времени с фактическим и удостовериться, что таймер при запуске игры устанавливается верно.
__Тип__: позитивный тест
__Входные данные__: атрибут, хранящий значение таймера (int)
__Ожидаемый результат__: равенство предоставленных данных и константы, равной начальному значению таймера
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №8 этого блока проверяется, что начальное значение таймера, хранящееся в атрибуте класса, равно соответствующей константе, определённой в модуле с константами.  

### Тест № 1.9
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение начального счёта с фактическим и удостовериться, что счётчик при запуске игры устанавливается верно.
__Тип__: позитивный тест
__Входные данные__: атрибут, хранящий значение счёта на момент начала игры (int)
__Ожидаемый результат__: равенство предоставленных данных нулю
__Описание процесса__: После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №9 этого блока проверяется, что начальное значение счётчика, хранящееся в атрибуте класса, равно нулю.  
     
### Тест № 1.10
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение результата с фактическим и удостовериться, что флажок результата равен нулю при запуске игры.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий результат игры (int)
__Ожидаемый результат__: равенство предоставленных данных нулю.
__Описание процесса__: После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №10 этого блока проверяется, что результат игры, хранящийся в атрибуте класса, равен нулю.  

### Тест № 1.11
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение скорости изменения координаты x главного героя с фактическим и удостовериться, что по оси OX эта величина равна 0 при запуске игры.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий значение скорости изменения координаты x главного героя (int)
__Ожидаемый результат__: равенство предоставленных данных 0
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №11 этого блока проверяется, что скорость изменения координаты x главного героя равна 0.  

### Тест № 1.12
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение скорости изменения координаты y главного героя с фактическим и удостовериться, что по оси OY эта величина равна 0 при запуске игры.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий значение скорости изменения координаты y главного героя (int)
__Ожидаемый результат__: равенство предоставленных данных 0
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №12 этого блока проверяется, что скорость изменения координаты y главного героя равна 0.  

### Тест № 1.13
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение координаты x каждого из врагов с фактическим и удостовериться, что при запуске игры все положения врагов по оси OX генерируются корректно.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий координату x врага (int)
__Ожидаемый результат__: координата x врага не находится в области, занимаемой главным персонажем в начале игры.
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тестах №13 и №14 этого блока запущен цикл, перебирающий всех врагов, и проверяется, что координата x вражеского персонажа, хранящаяся в атрибуте класса, не попадает в "безопасный" диапазон главного героя: стартовую позицию и её окрестность по оси OX.

### Тест № 1.14
__Цель__: Проверить корректность запуска игры, сравнив ожидаемое значение координаты y каждого из врагов с фактическим и удостовериться, что при запуске игры все положения врагов по оси OY генерируются корректно.
__Тип__: позитивный
__Входные данные__: атрибут, хранящий координату y врага (int)
__Ожидаемый результат__: координата y врага не находится в области, занимаемой главным персонажем в начале игры.
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тестах №13 и №14 этого блока запущен цикл, перебирающий всех врагов, и проверяется, что координата y вражеского персонажа, хранящаяся в атрибуте класса, не попадает в "безопасный" диапазон главного героя: стартовую позицию и её окрестность по оси OY.  

### Тест № 1.15
__Цель__: Проверить корректность запуска игры, сравнив ожидаемые значение координат каждой из жизней с фактическими и удостовериться, что при запуске игры все координаты жизней заполнены корректно.
__Тип__: позитивный
__Входные данные__: кортеж (x, y), где x - координата x отрисовки жизни, y - координата y отрисовки жизни
__Ожидаемый результат__: равенство передаваемых входных данных и кортежа, содержащего верные позиции жизни
__Описание процесса__:  После инициализации игры вызываются имитация нажатия пробела и закрытия приложения, затем следует ряд проверок. В тесте №15 запускается цикл, проходящий по длине списка жизней (атрибуту тестируемого класса), и на каждой итерации цикла проверяется равенство входных данных и кортежа координат (x, y), считающихся следующим алгоритмом:  
            x = ScreenWidth - (i + 1)∙w_i
            y = 0, 
    где ScreenWidth - ширина экрана, взятая из модуля с константами, i - соответствующая итерация цикла, w_i - ширина изображения элемента с индексом i в списке жизней.   

### Тест № 1.16
__Цель__: Проверить корректность завершения игры, сравнив ожидаемое значение состояния игры с фактическим и удостовериться, что установка состояния работает верно при завершении игры (ненулевом значении атрибута game.result).
__Тип__: позитивный
__Входные данные__: атрибут, хранящий числовую характеристику текущего состояния игры (int)
__Ожидаемый результат__: равенство предоставленных данных числу 2
__Описание процесса__: После инициализации игры флаг состояний присваивается единице, флагу результата также присвоено целочисленное значение "1". Имитируется нажатие кнопки "Закрыть" для мгновенного закрытия приложения. Запускается игровой цикл. Проверяем, действительно ли значение состояния сменилось после переприсваивания флага результата.  

### Тест № 1.17
__Цель__: Проверить, была ли вызвана функция win из метода utils при ненулевом флаге результата (первый метод - через прямое присвоение флагу состояний числовой характеристики конечного состояния "2").
__Тип__: позитивный
__Входные данные__: экземпляр класса Game
__Ожидаемый результат__: отчёт о вызове функции
__Описание процесса__: После инициализации игры флагу состояний присваивается целое значение "2", флагу результата присвоено целочисленное значение "1". Имитируется нажатие кнопки "Закрыть" для мгновенного закрытия приложения. Используя технику мокирования (mock), заменяем функцию utils.win на mock_win. Запускается игровой цикл. Проверяем, была ли вызвана функция с помощью mock_win.assert_called_with(self.game).  

### Тест № 1.18
__Цель__: Проверить, была ли вызвана функция lose из метода utils при ненулевом флаге результата (первый метод - через прямое присвоение флагу состояний числовой характеристики конечного состояния "2").
__Тип__: позитивный
__Входные данные__: экземпляр класса Game
__Ожидаемый результат__: отчёт о вызове функции
__Описание процесса__: После инициализации игры флагу состояний присваивается целое значение "2", флагу результата присвоено целочисленное значение "-1". Имитируется нажатие кнопки "Закрыть" для мгновенного закрытия приложения. Используя технику мокирования (mock), заменяем функцию utils.lose на mock_lose. Запускается игровой цикл. Проверяем, была ли вызвана функция с помощью mock_lose.assert_called_with(self.game).  

### Тест № 1.19
__Цель__: Проверить, была ли вызвана функция win из метода utils при ненулевом флаге результата (второй метод - проверка перехода игры из состояния "1" в "2" с последующим вызовом функции win).
__Тип__: позитивный
__Входные данные__: экземпляр класса Game
__Ожидаемый результат__: отчёт о вызове функции
__Описание процесса__: После инициализации игры флагу состояний присваивается целое значение "1", флагу результата присвоено целочисленное значение "1". Имитируется нажатие кнопки "Закрыть" для мгновенного закрытия приложения. Используя технику мокирования (mock), заменяем функцию utils.win на mock_win. Запускается игровой цикл. Проверяем, была ли вызвана функция с помощью mock_win.assert_called_with(self.game).  

### Тест № 1.20
__Цель__: Проверить, была ли вызвана функция lose из метода utils при ненулевом флаге результата (второй метод - проверка перехода игры из состояния "1" в "2" с последующим вызовом функции lose).
__Тип__: позитивный
__Входные данные__: экземпляр класса Game
__Ожидаемый результат__: отчёт о вызове функции
__Описание процесса__: После инициализации игры флагу состояний присваивается целое значение "1", флагу результата присвоено целочисленное значение "-1". Имитируется нажатие кнопки "Закрыть" для мгновенного закрытия приложения. Используя технику мокирования (mock), заменяем функцию utils.lose на mock_lose. Запускается игровой цикл. Проверяем, была ли вызвана функция с помощью mock_lose.assert_called_with(self.game).  

### Тест № 1.21
__Цель__: Проверить, как реагирует программа на столкновение с врагом
__Тип__: позитивный
__Входные данные__: количество жизней
__Ожидаемый результат__: при первом столкновении с врагом атрибут, хранящий количество жизней на текущий момент игры, должен быть на одну единицу меньше константы, хранящей начальное (и максимальное) количество жизней
__Описание процесса__:  После инициализации игры флагу состояний присваивается целое значение "1", координатам главного персонажа присваиваются координаты случайным образом выбранного врага. Имитируется нажатие кнопки "Закрыть" для мгновенного закрытия приложения. Запускается игровой цикл. Проверяем равенство.  

### Тест № 1.22
__Цель__: Проверить, как реагирует программа на столкновение с врагом
__Тип__: позитивный
__Входные данные__: имя спрайта жизни с индексом lives_count - 1, где lives_count - константа, хранящая начальное (и максимальное) количество жизней
__Ожидаемый результат__: при первом столкновении с врагом имя спрайта жизни с индексом lives_count - 1 должно измениться на имя пустого изображения (для визуального исчезновения жизни с экрана)
__Описание процесса__:  После инициализации игры флагу состояний присваивается целое значение "1", координатам главного персонажа присваиваются координаты случайным образом выбранного врага. Имитируется нажатие кнопки "Закрыть" для мгновенного закрытия приложения. Запускается игровой цикл. Проверяем истинность утверждения.

### Тест № 1.23
__Цель__: Проверить, как реагирует программа на столкновение с ресурсом
__Тип__: позитивный
__Входные данные__: текущий счёт
__Ожидаемый результат__: при столкновении с врагом атрибут, хранящий текущий счёт игры, должен быть на одну единицу больше предыдущего значения счётчика.
__Описание процесса__:  После инициализации игры флагу состояний присваивается целое значение "1", в переменную score сохраняется счёт на момент начала тестирования. Затем координатам главного персонажа присваиваются координаты ресурса. Имитируется нажатие кнопки "Закрыть" для мгновенного закрытия приложения. Запускаем игровой цикл. Проверяем, достигнуто ли ожидаемое равенство.  

### Тест № 1.24
__Цель__: Проверить, как реагирует программа на столкновение с ресурсом
__Тип__: позитивный
__Входные данные__: отсутствуют
__Ожидаемый результат__: отчёт о вызове функции
__Описание процесса__:  После инициализации игры флагу состояний присваивается целое значение "1", в переменную score сохраняется счёт на момент начала тестирования. Затем координатам главного персонажа присваиваются координаты ресурса. Имитируется нажатие кнопки "Закрыть" для мгновенного закрытия приложения. Используя технику мокирования (mock), заменяем метод Resource.regen() дял объекта game.res на mock_regen. Запускается игровой цикл. Проверяем, был ли вызван метод с помощью mock_regen.assert_called().  


### Тест № 1.25
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата x главного игрового персонажа
__Ожидаемый результат__: равенство по оси OX новой и старой координат
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_x сохраняется значение координаты x на момент начала тестирования. Имитируются нажатия клавиш "W" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.26
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата y главного игрового персонажа
__Ожидаемый результат__: новая координата по оси OY  меньше старой координаты
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_y сохраняется значение координаты y на момент начала тестирования. Имитируются нажатия клавиш "W" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.27
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата x главного игрового персонажа
__Ожидаемый результат__: равенство по оси OX новой и старой координат
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_x сохраняется значение координаты x на момент начала тестирования. Имитируются нажатия клавиш "стрелка вверх" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.28
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата y главного игрового персонажа
__Ожидаемый результат__: новая координата по оси OY  меньше старой координаты
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_y сохраняется значение координаты y на момент начала тестирования. Имитируются нажатия клавиш "стрелка вверх" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство.  

### Тест № 1.29
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата x главного игрового персонажа
__Ожидаемый результат__: равенство по оси OX новой и старой координат
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_x сохраняется значение координаты x на момент начала тестирования. Имитируются нажатия клавиш "S" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.30
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата y главного игрового персонажа
__Ожидаемый результат__: новая координата по оси OY больше старой координаты
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_y сохраняется значение координаты y на момент начала тестирования. Имитируются нажатия клавиш "S" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.31
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата x главного игрового персонажа
__Ожидаемый результат__: равенство по оси OX новой и старой координат
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_x сохраняется значение координаты x на момент начала тестирования. Имитируются нажатия клавиш "стрелка вниз" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.32
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата y главного игрового персонажа
__Ожидаемый результат__: новая координата по оси OY больше старой координаты
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_y сохраняется значение координаты y на момент начала тестирования. Имитируются нажатия клавиш "стрелка вниз" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство.  

### Тест № 1.33
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата x главного игрового персонажа
__Ожидаемый результат__: новая координата по оси OX меньше старой координаты
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_x сохраняется значение координаты x на момент начала тестирования. Имитируются нажатия клавиш "A" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.34
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата y главного игрового персонажа
__Ожидаемый результат__: равенство по оси OY новой и старой координат
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_y сохраняется значение координаты y на момент начала тестирования. Имитируются нажатия клавиш "A" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.35
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата x главного игрового персонажа
__Ожидаемый результат__: новая координата по оси OX меньше старой координаты
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_x сохраняется значение координаты x на момент начала тестирования. Имитируются нажатия клавиш "стрелка влево" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.36
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата y главного игрового персонажа
__Ожидаемый результат__: равенство по оси OY новой и старой координат
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_y сохраняется значение координаты y на момент начала тестирования. Имитируются нажатия клавиш "стрелка влево" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство.  

### Тест № 1.37
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата x главного игрового персонажа
__Ожидаемый результат__: новая координата по оси OX больше старой координаты
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_x сохраняется значение координаты x на момент начала тестирования. Имитируются нажатия клавиш "D" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.38
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата y главного игрового персонажа
__Ожидаемый результат__: равенство по оси OY новой и старой координат
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_y сохраняется значение координаты y на момент начала тестирования. Имитируются нажатия клавиш "D" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.39
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата x главного игрового персонажа
__Ожидаемый результат__: новая координата по оси OX больше старой координаты
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_x сохраняется значение координаты x на момент начала тестирования. Имитируются нажатия клавиш "стрелка вправо" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство. 

### Тест № 1.40
__Цель__: Проверить, как срабатывает программа при нажатии пользователем клавиши; корректно ли осуществлен сдвиг персонажа
__Тип__: позитивный
__Входные данные__: координата y главного игрового персонажа
__Ожидаемый результат__: равенство по оси OY новой и старой координат
__Описание процесса__:  Для каждой проверки игра перезапускается методом restart(). В переменную start_y сохраняется значение координаты y на момент начала тестирования. Имитируются нажатия клавиш "стрелка вправо" и закрытия приложения. Запускается игровой цикл, после чего проверяется требуемое равенство.  

### Тест № 2.1
__Цель__: Проверить работу игры при значении game.result, большего единицы по модулю.
__Тип__: негативный
__Входные данные__:  атрибут, хранящий целочисленную характеристику состояния игры
__Ожидаемый результат__: переход на game.state = 2
__Описание процесса__:  После инициализации игры имитируется нажатие пробела для её запуска, закрытия для мгновенного завершения работы. После чего атрибуту game.result присваивается значение 1000. Игровой цикл запускается, по итогу получаем необходимое нам равенство game.state == 2.  

### Тест № 2.2
__Цель__: Проверить работу игры при нажатии клавиши, не предусмотренной логикой игры
__Тип__: негативный
__Входные данные__:  атрибут, хранящий целочисленную характеристику состояния игры
__Ожидаемый результат__: game.state не изменится и останется равным нулю.
__Описание процесса__:  После инициализации игры имитируется нажатие клавиш ESCAPE, закрытия для мгновенного завершения работы. После чего проверяется равенство self.assertEqual(game.state, 0)

### Тест № 2.3
__Цель__: Проверить работу игры при нажатии клавиши, не предусмотренной логикой игры
__Тип__: негативный
__Входные данные__:  координата x игрового персонажа
__Ожидаемый результат__: входные данные останутся неизменными (равными начальным)
__Описание процесса__:  После инициализации игры переменной состояния присваивается значение "1" (основное действие игры), в переменной start_x фиксируется начальная координата персонажа по оси иксов; имитируется нажатие клавиш ESCAPE, закрытия для мгновенного завершения работы. После чего проверяется равенство текущей координаты x и начального её значения.  

### Тест № 2.4
__Цель__: Проверить работу игры при нажатии клавиши, не предусмотренной логикой игры
__Тип__: негативный
__Входные данные__:  координата y игрового персонажа
__Ожидаемый результат__: входные данные останутся неизменными (равными начальным)
__Описание процесса__:  После инициализации игры переменной состояния присваивается значение "1" (основное действие игры), в переменной start_y фиксируется начальная координата персонажа по оси иксов; имитируется нажатие клавиш ESCAPE, закрытия для мгновенного завершения работы. После чего проверяется равенство текущей координаты y и начального её значения.

### Тест № 2.5
__Цель__: Проверить работу игры при нажатии клавиши, не предусмотренной логикой игры
__Тип__: негативный
__Входные данные__:  атрибут, хранящий целочисленную характеристику состояния игры
__Ожидаемый результат__: game.state не изменится и останется равным двум.
__Описание процесса__:  После инициализации игры имитируется нажатие клавиш ESCAPE, закрытия для мгновенного завершения работы. После чего проверяется равенство self.assertEqual(game.state, 2)

# Модуль characters
## Метод Main.reset()

### Тест № 1.1
__Цель__: Проверить работу метода reset() класса Main, удостоверившись, что  координата x устанавливается в центр экрана (начальное значение, определенное модулем констант)
__Тип__: позитивный
__Входные данные__: атрибут x экземпляра класса Main
__Ожидаемый результат__: равенство передаваемых данных и константы constantants.start_x
__Описание процесса__: 
    Создётся экземпляр класса Main, после чего атрибуту x присваивается значение, находящееся в пределах игрового поля (=10), но отличное от начальной координаты. Вызывается метод reset(). Проверяется равенство полученной координаты x у экземпляра и стартовой координаты x.  
    
### Тест № 1.2
__Цель__: Проверить работу метода reset() класса Main, удостоверившись, что  координата y устанавливается в центр экрана (начальное значение, определенное модулем констант)
__Тип__: позитивный
__Входные данные__: атрибут y экземпляра класса Main
__Ожидаемый результат__: равенство передаваемых данных и константы constantants.start_y
__Описание процесса__: 
    Создётся экземпляр класса Main, после чего атрибуту y присваивается значение, находящееся в пределах игрового поля (=-10), но отличное от начальной координаты. Вызывается метод reset(). Проверяется равенство полученной координаты y у экземпляра и стартовой координаты y.
    
### Тест № 1.3
__Цель__: Проверить работу метода reset() класса Main, удостоверившись, что скорость изменения координаты x (атрибут vx) остается неизменной
__Тип__: позитивный
__Входные данные__: атрибут vx экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода reset() должен остаться без изменений.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vx присваивается ненулевое значение (=5), которое также сохраняется в переменную prev_vx. Вызывается метод reset(). Проверяется равенство полученного значения vx у экземпляра и сохраненного начального значения prev_vx.

### Тест № 1.4
__Цель__: Проверить работу метода reset() класса Main, удостоверившись, что скорость изменения координаты y (атрибут vy) остается неизменной
__Тип__: позитивный
__Входные данные__: атрибут vy экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода reset() должен остаться без изменений.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vy присваивается ненулевое значение (=-6), которое также сохраняется в переменную prev_vy. Вызывается метод reset(). Проверяется равенство полученного значения vy у экземпляра и сохраненного начального значения prev_vy.

### Тест № 2.1
__Цель__: Проверить работу метода reset() класса Main при значении, выходящем за границу, удостоверившись, что координата x устанавливается в центр экрана (начальное значение, определенное модулем констант)
__Тип__: негативный
__Входные данные__: атрибут x экземпляра класса Main
__Ожидаемый результат__: равенство передаваемых данных и константы constantants.start_x
__Описание процесса__: 
    Создётся экземпляр класса Main, после чего атрибуту x присваивается значение, находящееся за пределами игрового поля (=-123456789). Вызывается метод reset(). Проверяется равенство полученной координаты x у экземпляра и стартовой координаты x.  
    
### Тест № 2.2
__Цель__: Проверить работу метода reset() класса Main при значении, выходящем за границу, удостоверившись, что координата y устанавливается в центр экрана (начальное значение, определенное модулем констант)
__Тип__: негативный
__Входные данные__: атрибут y экземпляра класса Main
__Ожидаемый результат__: равенство передаваемых данных и константы constantants.start_y
__Описание процесса__: 
    Создётся экземпляр класса Main, после чего атрибуту y присваивается значение, находящееся за пределами игрового поля (=987654321). Вызывается метод reset(). Проверяется равенство полученной координаты y у экземпляра и стартовой координаты y.
    
### Тест № 2.3
__Цель__: Проверить работу метода reset() класса Main при значении, выходящем за границу, удостоверившись, что скорость изменения координаты x (атрибут vx) остается неизменной
__Тип__: негативный
__Входные данные__: атрибут vx экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода reset() должен остаться без изменений.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vx присваивается ненулевое значение (=-103900923902), превышающее пределы игровых значений, которое также сохраняется в переменную prev_vx. Вызывается метод reset(). Проверяется равенство полученного значения vx у экземпляра и сохраненного начального значения prev_vx.

### Тест № 2.4
__Цель__: Проверить работу метода reset() класса Main при значении, выходящем за границу, удостоверившись, что скорость изменения координаты y (атрибут vy) остается неизменной
__Тип__: негативный
__Входные данные__: атрибут vy экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода reset() должен остаться без изменений.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vy присваивается ненулевое значение (=9239809029009340034), превышающее пределы игровых значений, которое также сохраняется в переменную prev_vy. Вызывается метод reset(). Проверяется равенство полученного значения vy у экземпляра и сохраненного начального значения prev_vy.


## Метод Main.regen()

### Тест № 1.1
__Цель__: Проверить работу метода regen() класса Main, удостоверившись, что  координата x устанавливается в центр экрана (начальное значение, определенное модулем констант)
__Тип__: позитивный
__Входные данные__: атрибут x экземпляра класса Main
__Ожидаемый результат__: равенство передаваемых данных и константы constantants.start_x
__Описание процесса__: 
    Создётся экземпляр класса Main, после чего атрибуту x присваивается значение, находящееся в пределах игрового поля (=-10), но отличное от начальной координаты. Вызывается метод regen(). Проверяется равенство полученной координаты x у экземпляра и стартовой координаты x.  
    
### Тест № 1.2
__Цель__: Проверить работу метода regen() класса Main, удостоверившись, что  координата y устанавливается в центр экрана (начальное значение, определенное модулем констант)
__Тип__: позитивный
__Входные данные__: атрибут y экземпляра класса Main
__Ожидаемый результат__: равенство передаваемых данных и константы constantants.start_y
__Описание процесса__: 
    Создётся экземпляр класса Main, после чего атрибуту y присваивается значение, находящееся в пределах игрового поля (=10), но отличное от начальной координаты. Вызывается метод regen(). Проверяется равенство полученной координаты y у экземпляра и стартовой координаты y.
    
### Тест № 1.3
__Цель__: Проверить работу метода regen() класса Main, удостоверившись, что скорость изменения координаты x (атрибут vx) приравнивается к нулю
__Тип__: позитивный
__Входные данные__: атрибут vx экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода regen() должен быть равным нулю.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vx присваивается ненулевое значение (=-5), которое также сохраняется в переменную prev_vx. Вызывается метод regen(). Проверяется равенство полученного значения vx у экземпляра и нуля.

### Тест № 1.4
__Цель__: Проверить работу метода regen() класса Main, удостоверившись, что скорость изменения координаты y (атрибут vy) приравнивается к нулю
__Тип__: позитивный
__Входные данные__: атрибут vy экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода regen() должен быть равным нулю.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vy присваивается ненулевое значение (=6), которое также сохраняется в переменную prev_vy. Вызывается метод regen(). Проверяется равенство полученного значения vy у экземпляра и нуля.

### Тест № 1.5
__Цель__: Проверить работу метода regen() класса Main, удостоверившись, что скорость изменения координаты x (атрибут vx) изменяется
__Тип__: позитивный
__Входные данные__: атрибут vx экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода regen() должен быть отличен от начального значения.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vx присваивается ненулевое значение (=-5), которое также сохраняется в переменную prev_vx. Вызывается метод regen(). Проверяется отсутствие равенства у атрибута vx и переменной prev_x.
### Тест № 1.6
__Цель__: Проверить работу метода regen() класса Main, удостоверившись, что скорость изменения координаты y (атрибут vy) изменяется
__Тип__: позитивный
__Входные данные__: атрибут vy экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода regen() должен быть отличен от начального значения.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vy присваивается ненулевое значение (=6), которое также сохраняется в переменную prev_vy. Вызывается метод regen(). Проверяется отсутствие равенства у атрибута vy и переменной prev_y.


### Тест № 2.1
__Цель__: Проверить работу метода regen() класса Main при значении, выходящем за границу, удостоверившись, что  координата x устанавливается в центр экрана (начальное значение, определенное модулем констант)
__Тип__: негативный
__Входные данные__: атрибут x экземпляра класса Main
__Ожидаемый результат__: равенство передаваемых данных и константы constantants.start_x
__Описание процесса__: 
    Создётся экземпляр класса Main, после чего атрибуту x присваивается значение, находящееся за пределами игрового поля (=100000). Вызывается метод regen(). Проверяется равенство полученной координаты x у экземпляра и стартовой координаты x.  
    
### Тест № 2.2
__Цель__: Проверить работу метода regen() класса Main при значении, выходящем за границу, удостоверившись, что  координата y устанавливается в центр экрана (начальное значение, определенное модулем констант)
__Тип__: негативный
__Входные данные__: атрибут y экземпляра класса Main
__Ожидаемый результат__: равенство передаваемых данных и константы constantants.start_y
__Описание процесса__: 
    Создётся экземпляр класса Main, после чего атрибуту y присваивается значение, находящееся за пределами игрового поля (=-10000000). Вызывается метод regen(). Проверяется равенство полученной координаты y у экземпляра и стартовой координаты y.
    
### Тест № 2.3
__Цель__: Проверить работу метода regen() класса Main при значении, выходящем за границу, удостоверившись, что скорость изменения координаты x (атрибут vx) приравнивается к нулю
__Тип__: негативный
__Входные данные__: атрибут vx экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода regen() должен быть равным нулю.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vx присваивается ненулевое значение (=1000), которое также сохраняется в переменную prev_vx. Вызывается метод regen(). Проверяется равенство полученного значения vx у экземпляра и нуля.

### Тест № 2.4
__Цель__: Проверить работу метода regen() класса Main при значении, выходящем за границу, удостоверившись, что скорость изменения координаты y (атрибут vy) приравнивается к нулю
__Тип__: негативный
__Входные данные__: атрибут vy экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода regen() должен быть равным нулю.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vy присваивается ненулевое значение (=-1000), которое также сохраняется в переменную prev_vy. Вызывается метод regen(). Проверяется равенство полученного значения vy у экземпляра и нуля.

### Тест № 2.5
__Цель__: Проверить работу метода regen() класса Main при значении, выходящем за границу, удостоверившись, что скорость изменения координаты x (атрибут vx) изменяется
__Тип__: негативный
__Входные данные__: атрибут vx экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода regen() должен быть отличен от начального значения.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vx присваивается ненулевое значение (=1000), которое также сохраняется в переменную prev_vx. Вызывается метод regen(). Проверяется отсутствие равенства у атрибута vx и переменной prev_x.
### Тест № 2.6
__Цель__: Проверить работу метода regen() класса Main, удостоверившись, что скорость изменения координаты y (атрибут vy) изменяется
__Тип__: негативный
__Входные данные__: атрибут vy экземпляра класса Main
__Ожидаемый результат__: передаваемый на проверку атрибут после вызове метода regen() должен быть отличен от начального значения.
__Описание процесса__:  Создаётся экземпляр класса Main, после чего атрибуту vy присваивается ненулевое значение (=-1000), которое также сохраняется в переменную prev_vy. Вызывается метод regen(). Проверяется отсутствие равенства у атрибута vy и переменной prev_y.

## Метод Enemy.regen()  

### Тест № 1.1
__Цель__: Проверить работу метода regen() класса Enemy, удостоверившись, что координата x сменилась
__Тип__: позитивный
__Входные данные__: атрибут x экземпляра класса Enemy
__Ожидаемый результат__: атрибут x будет иметь другое значение после вызова метода regen
__Описание процесса__:  Создаётся экземпляр класса Main (main; координаты экземпляра класса Enemy (self.enemy) приравниваются к координатам объекта main и сохраняются в переменных original_x, original_y. Используя метод мокирования (mock), задаём функции random.choice() возвращаемое значение 100, чтобы можно было проверить выбор; вызываем метод regen(). Проверяется отсутствие равенства новой координаты x и старой (original_x)

### Тест № 1.1
__Цель__: Проверить работу метода regen() класса Enemy, удостоверившись, что координата x сменилась
__Тип__: позитивный
__Входные данные__: атрибут x экземпляра класса Enemy
__Ожидаемый результат__: атрибут x будет иметь другое значение после вызова метода regen
__Описание процесса__:  Создаётся экземпляр класса Main (main); координаты экземпляра класса Enemy (self.enemy) приравниваются к координатам объекта main и сохраняются в переменных original_x, original_y. Используя метод мокирования (mock), задаём функции random.choice() возвращаемое значение 100, чтобы можно было проверить выбор; вызываем метод regen(). Проверяется отсутствие равенства между новой координатой x и старой (original_x)

### Тест № 1.2
__Цель__: Проверить работу метода regen() класса Enemy, удостоверившись, что координата y сменилась
__Тип__: позитивный
__Входные данные__: атрибут x экземпляра класса Enemy
__Ожидаемый результат__: атрибут y будет иметь другое значение после вызова метода regen
__Описание процесса__:  Создаётся экземпляр класса Main (main); координаты экземпляра класса Enemy (self.enemy) приравниваются к координатам объекта main и сохраняются в переменных original_x, original_y. Используя метод мокирования (mock), задаём функции random.choice() возвращаемое значение 100, чтобы можно было проверить выбор; вызываем метод regen(). Проверяется отсутствие равенства между новой координатой y и старой (original_y)

### Тест № 1.3
__Цель__: Проверить работу метода regen() класса Enemy, удостоверившись, что координата x сменилась, проверив возврат функции random.choice()
__Тип__: позитивный
__Входные данные__: атрибут x экземпляра класса Enemy
__Ожидаемый результат__: атрибут x будет иметь другое значение после вызова метода regen () возврат функции random.choice()
__Описание процесса__:  Создаётся экземпляр класса Main (main); координаты экземпляра класса Enemy (self.enemy) приравниваются к координатам объекта main и сохраняются в переменных original_x, original_y. Используя метод мокирования (mock), задаём функции random.choice() возвращаемое значение 100, чтобы можно было проверить выбор; вызываем метод regen(). Проверяется, что значение координаты x равно значению, возвращенному функцией random.choice() в рамках вызова метода regen() (x = 100)

### Тест № 1.4
__Цель__: Проверить работу метода regen() класса Enemy, удостоверившись, что координата x сменилась, проверив возврат функции random.choice()
__Тип__: позитивный
__Входные данные__: атрибут x экземпляра класса Enemy 
__Ожидаемый результат__: будет иметь другое значение после вызова метода regen () возврат функции random.choice()
__Описание процесса__: Создаётся экземпляр класса Main (main); координаты экземпляра класса Enemy (self.enemy) приравниваются к координатам объекта main и сохраняются в переменных original_x, original_y. Используя метод мокирования (mock), задаём функции random.choice() возвращаемое значение 100, чтобы можно было проверить выбор; вызываем метод regen(). Проверяется, что значение координаты y равно значению, возвращенному функцией random.choice() в рамках вызова метода regen() (y = 100)  

# Модуль add
## Класс Resource

### Тест № 1.1
__Цель__: Проверить корректность создания экземпляров класса Resource с помощью мокирования функции random.choice()
__Тип__: позитивный
__Входные данные__: координата x экземпляра класса
__Ожидаемый результат__: проверяемая координата будет равна заданному возвращаемому значению функции random.choice()
__Описание процесса__:  Используя технику мокирования (mock), задаём возвращаемое значение для функции random.choice(), равное 100, после чего создаем экземпляр класса Resource. Координата x должна быть равна 100.

### Тест № 1.2
__Цель__: Проверить корректность создания экземпляров класса Resource с помощью мокирования функции random.choice()
__Тип__: позитивный
__Входные данные__: координата y экземпляра класса
__Ожидаемый результат__: проверяемая координата будет равна заданному возвращаемому значению функции random.choice()
__Описание процесса__:  Используя технику мокирования (mock), задаём возвращаемое значение для функции random.choice(), равное 100, после чего создаем экземпляр класса Resource. Координата y должна быть равна 100.

## Метод Resource.regen()

### Тест № 1.1
__Цель__: Проверить работу метода regen() класса Resource, удостоверившись, что координата x сменилась
__Тип__: позитивный
__Входные данные__: атрибут x экземпляра класса Resource
__Ожидаемый результат__: проверяемая координата будет равна заданному возвращаемому значению функции random.choice()
__Описание процесса__:  Используя технику мокирования (mock), задаём возвращаемое значение для функции random.choice(), равное 100, после чего создаем экземпляр класса Resource. Координата x должна быть равна 100.

### Тест № 1.2
__Цель__: Проверить работу метода regen() класса Resource, удостоверившись, что координата y сменилась
__Тип__: позитивный
__Входные данные__: атрибут y экземпляра класса Resource
__Ожидаемый результат__: проверяемая координата будет равна заданному возвращаемому значению функции random.choice()
__Описание процесса__:  Используя технику мокирования (mock), задаём возвращаемое значение для функции random.choice(), равное 100, после чего создаем экземпляр класса Resource. Координата y должна быть равна 100.

## Метод Life.destroy

### Тест № 1.1
__Цель__: Проверить корректность создания экземпляров класса Life
__Тип__: позитивный
__Входные данные__: наименование спрайта созданного экземпляра
__Ожидаемый результат__: наименование спрайта будет совпадать с определенным в модуле констант соответствующим значением
__Описание процесса__:  Создаётся экземпляр класса Life, после чего проверяется совпадение имён.

### Тест № 1.2
__Цель__: Проверить корректность работы метода destroy класса Life
__Тип__: позитивный
__Входные данные__: наименование спрайта созданного экземпляра после вызова метода destroy()
__Ожидаемый результат__: наименование спрайта будет совпадать с определенным в модуле констант соответствующим значением пустого спрайта
__Описание процесса__:  Создаётся экземпляр класса Life, вызывается метод destroy(), после чего проверяется совпадение имён

# Модуль sprites

### Тест № 1.1
__Цель__: Проверить корректность создания экземпляров класса Sprite через имя спрайта
__Тип__: позитивный
__Входные данные__: наименование спрайта созданного экземпляра
__Ожидаемый результат__: наименование спрайта будет совпадать с определенным в модуле констант соответствующим значением
__Описание процесса__:  Создаётся переменная, содержащая путь до изображения "assets/character.png" из подкаталога "assets", расположенного в корневой папке проекта; создаётся экземпляр класса Sprite. После создания проверяется совпадение атрибута с именем и самой переменной-имени (таким образом проверяется корректность)

### Тест № 1.2
__Цель__: Проверить корректность создания экземпляров класса Sprite через размеры спрайта
__Тип__: позитивный
__Входные данные__: атрибут, хранящий в себе ширину изображения
__Ожидаемый результат__: начение атрибута совпадёт с размером изображения (взятым из свойств объекта)
__Описание процесса__: Создаётся переменная, содержащая путь до изображения "assets/character.png" из подкаталога "assets", расположенного в корневой папке проекта; создаётся экземпляр класса Sprite. После создания проверяется равенство атрибута с шириной и непосредственно числовому значению ширины изображения


### Тест № 1.3
__Цель__: Проверить корректность создания экземпляров класса Sprite через размеры спрайта
__Тип__: позитивный
__Входные данные__: атрибут, хранящий в себе высоту изображения
__Ожидаемый результат__: значение атрибута совпадёт с размером изображения (взятым из свойств объекта)
__Описание процесса__:  Создаётся переменная, содержащая путь до изображения "assets/character.png" из подкаталога "assets", расположенного в корневой папке проекта; создаётся экземпляр класса Sprite. После создания проверяется равенство атрибута с высотой и непосредственно числовому значению высоты изображения

### Тест № 2.1
__Цель__: Проверить обработку ошибок при создании экземпляра класса Sprite
__Тип__: негативный
__Входные данные__: путь к изображению
__Ожидаемый результат__: выброшенное исключение будет говорить об успешно пройденном тесте
__Описание процесса__:  Создаётся переменная, содержащая неверный путь до изображения "invalid/path/character.png"; производится попытка создать экземпляр класса Sprite. При выброшенном исключении FileNotFound тест будет считаться успешно пройденным.

